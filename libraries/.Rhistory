source("http://bioconductor.org/biocLite.R")
biocLite()
source("http://bioconductor.org/biocLite.R")
biocLite("xcms")
source("http://bioconductor.org/biocLite.R")
biocLite("data.table")
install.packages("O:/Groups/LPS/Software/Imaging/imageScope_0.1.tar.gz", repos = NULL, type = "source")
install.packages("rJava")
install.packages("calibrate")
install.packages("O:/Groups/LPS/Software/Imaging/imageScope_0.1.tar.gz", repos = NULL, type = "source")
install.packages("~/R/win-library/3.1/rJava/libs/x64/rJava.dll", repos = NULL)
install.packages('rJava')
install.packages("rJava")
library(rJava)
packages()
list()
list
?filled.contour
?key.title
?plot
setwd("C:/Users/hallz/Documents/Processing_temp/Zsuzsi_oxford_heart/first10") # where your mzML files are stored
FWHM <- 3 # set approximate FWHM (in seconds) of chromatographic peaks
bin.ppm = 20 # set your desired binning ppm
snthresh = 25 # set the signal to noise threshold
library(xcms)
profmethod = "binlin"  # use either "bin" (better for centroid, default), "binlin" (better for profile)
# place converted mzML files in working directory
path <- paste(getwd())
files <- list.files(path, recursive=T, full.names=F, pattern=".mzML")
# xcms scripts for peak picking and integration
xset <- xcmsSet(files, method="matchedFilter", step = 0.1, sigma=FWHM/2.3548, snthresh=snthresh, profmethod=profmethod) #feature recognition and convert group of files to xcms raw object
xset <- group(xset)# groups peaks, temporarily
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 1, extra = 1) # corrects retention times
xset2 <- group(xset2, bw = 5, sleep = 0.05, minfrac = 0.5) # groups data based on corrected retention times
names <- groupnames(xset2, rtdec=2, mzdec=4)  # define decimal places for mz and RT values
rownames(out) <- substr(names, 2, 18) # adjust row name
out <- groupval(xset2, method="maxint", value="maxo", intensity="maxo") # if multiple peaks choose one with highest intensity based on maxo (peak hieght raw)
rownames(out) <- substr(names, 2, 18) # adjust row name
rownames(out)
names2 <- rownames(out)
names2
out
strsplit(names2), split="T")
lapply(strsplit(names2), split="T")
lapply(strsplit((names2), split="T"))
lapply(strsplit((names2), split="T"), "[",1))
strsplit(names2), split="T")
strsplit(names2), split=T)
strsplit(names2, split=T)
strsplit(names2, split="T")
names2
names3 <- strsplit(names2, split="T")
names3
str(names3)
CLASS(names3)
class(names3)
names3[1]
names3[[1]
]
??sublist
subListExtract(names3, 1)
?split
split(names3 )
split(names3, 1 )
names3
class(names3)
str(names3)
names3[1]
testing <- names3[1]
testing
strsplit(testing, " ")
class(testing)
str(testing)
as.string(testing)
as.list(testing)
as.vector(testing)
b <- as.vector(testing)
b
?colsplit
unlist(strsplit(testing, "\\."))
colsplit(names3, split=" ", x)
library(reshape)
library("reshape2", lib.loc="~/R/win-library/3.1")
library(reshape2)
?colsplit
colsplit(names3, "T", c("mz", "RT"))
names3
colsplit(names3, " ", c("mz", "RT"))
colsplit(as.vector(names3), " ", c("mz", "RT"))
as.vector(names3)
class(as.vector(names3))
class(as.vector(as.character(names3)))
colsplit(as.vector(as.character(names3)), " ", c("mz", "RT"))
d <- colsplit(as.vector(as.character(names3)), " ", c("mz", "RT"))
d
class(d)
names <- groupnames(xset2, rtdec=2, mzdec=4)  # define decimal places for mz and RT values
names <- substr(names, 2, 18)
names <- colsplit(as.vector(as.character(names)), " ", c("mz", "RT"))
out <- groupval(xset2, method="maxint", value="maxo", intensity="maxo") # if multiple peaks choose one with highest intensity based on maxo (peak hieght raw)
rownames(out) <- names
names <- groupnames(xset2, rtdec=2, mzdec=4)  # define decimal places for mz and RT values
names
names <- substr(names, 2, 18)
names
names <- colsplit(as.vector(as.character(names)), " ", c("mz", "RT"))
names
names <- groupnames(xset2, rtdec=2, mzdec=4)  # define decimal places for mz and RT values
names <- substr(names, 2, 18)
names <- colsplit(as.vector(as.character(names)), "T", c("mz", "RT"))
names
out <- groupval(xset2, method="maxint", value="maxo", intensity="maxo") # if multiple peaks choose one with highest intensity based on maxo (peak hieght raw)
rownames(out) <- names
out[is.na(out)] <- 0 # replace NAs with 0
rownames(out) <- names
names
class(names)
str(names)
rownames(out) <- names$mz
cbind(out, names$RT)
out2 <- cbind(names$RT, out)
out2
nrow(out2)
ncol(out2)
out2[1:10, 1:10]
cbind(out, names$RT)
names <- groupnames(xset2, rtdec=2, mzdec=4)  # define decimal places for mz and RT values
names <- substr(names, 2, 18)
names <- colsplit(as.vector(as.character(names)), "T", c("mz", "RT"))
out <- groupval(xset2, method="maxint", value="maxo", intensity="maxo") # if multiple peaks choose one with highest intensity based on maxo (peak hieght raw)
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0 # replace NAs with 0
write.csv(out, "xcms_peak_height_raw.csv")
names <- groupnames(xset2, rtdec=2, mzdec=4)  # define decimal places for mz and RT values
names <- substr(names, 2, 18)
names <- colsplit(as.vector(as.character(names)), "T", c("mz", "RT"))
out <- groupval(xset2, method="maxint", value="maxo", intensity="maxo") # if multiple peaks choose one with highest intensity based on maxo (peak hieght raw)
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0 # replace NAs with 0
write.csv(out, "xcms_peak_height_raw.csv")
out <- groupval(xset2, method="maxint", value="maxf", intensity="maxo")
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0
write.csv(out, "xcms_peak_height_filtered.csv")
out <- groupval(xset2, method="maxint", value="into", intensity="maxo")
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0
write.csv(out, "xcms_peak_area_raw.csv")
out <- groupval(xset2, method="maxint", value="intf", intensity="maxo")
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0
write.csv(out, "xcms_peak_area_filtered.csv")
setwd("C:/Users/hallz/Documents/Processing_temp/Nyasha") # where your mzML files are stored
FWHM <- 3 # set approximate FWHM (in seconds) of chromatographic peaks
bin.ppm = 20 # set your desired binning ppm
snthresh = 20 # set the signal to noise threshold
library(xcms)
profmethod = "binlin"  # use either "bin" (better for centroid, default), "binlin" (better for profile)
# place converted mzML files in working directory
path <- paste(getwd())
files <- list.files(path, recursive=T, full.names=F, pattern=".mzML")
# xcms scripts for peak picking and integration
xset <- xcmsSet(files, method="matchedFilter", step = 0.1, sigma=FWHM/2.3548, snthresh=snthresh, profmethod=profmethod) #feature recognition and convert group of files to xcms raw object
xset <- group(xset)# groups peaks, temporarily
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 1, extra = 1) # corrects retention times
xset2 <- group(xset2, bw = 5, sleep = 0.05, minfrac = 0.5) # groups data based on corrected retention times
xset2 <- group(xset2, bw = 5, sleep = 0.05, minfrac = 0.2) # groups data based on corrected retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.3, missing = 1, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "linear", span = 0.3, missing = 1, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "linear", span = 0.2, missing = 1, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "linear", span = 0.2, missing = 10, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "linear", span = 0.2, missing = 100, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "linear", span = 0.2, missing = 90, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 90, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 60, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 40, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2,  extra = 1) # corrects retention times
0
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 40, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 30, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 20, extra = 1) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 20, extra = 5) # corrects retention times
xset2 <- group(xset2, bw = 5, sleep = 0.05, minfrac = 0.2) # groups data based on corrected retention times
names <- groupnames(xset2, rtdec=2, mzdec=4)  # define decimal places for mz and RT values
names <- substr(names, 2, 18)
names <- colsplit(as.vector(as.character(names)), "T", c("mz", "RT"))
out <- groupval(xset2, method="maxint", value="maxo", intensity="maxo") # if multiple peaks choose one with highest intensity based on maxo (peak hieght raw)
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0 # replace NAs with 0
write.csv(out, "xcms_peak_height_raw.csv")
out <- groupval(xset2, method="maxint", value="maxf", intensity="maxo")
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0
write.csv(out, "xcms_peak_height_filtered.csv")
out <- groupval(xset2, method="maxint", value="into", intensity="maxo")
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0
write.csv(out, "xcms_peak_area_raw.csv")
out <- groupval(xset2, method="maxint", value="intf", intensity="maxo")
rownames(out) <- names$mz
out <- cbind(names$RT, out)
out[is.na(out)] <- 0
write.csv(out, "xcms_peak_area_filtered.csv")
# plot extracted ion chromatograms for each peak group (corrected RT)
xset3 <- fillPeaks(xset2) # fills in missing peaks
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 20, extra = 5) # corrects retention times
xset2 <- retcor(xset, family = "symmetric", plottype = "mdevden", smooth = "loess", span = 0.2, missing = 1, extra = 1) # corrects retention times
save.image("~/Processing_temp/Nyasha/rhist.RData")
xset
getwd()
library(gplots)
library(RColorBrewer)
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
col_breaks = c(seq(-1,0,length=100),  # for red
seq(0,0.8,length=100),              # for yellow
seq(0.8,1,length=100))              # for green
png("../heatmaps_in_r.png",    # create PNG for the heat map
width = 5*300,        # 5 x 300 pixels
height = 5*300,
res = 300,            # 300 pixels per inch
pointsize = 8)        # smaller font size
pareto <- read.csv("pareto_scale.csv", header=T)
rownames(pareto) <- pareto[,1]
pareto2 <- t(as.matrix(pareto[,2:ncol(pareto)]))
heatmap.2(pareto2,
#cellnote = pareto2,  # same data set for cell labels
main = "Pareto scaled and signal normalised", # heat map title
# notecol="none",      # change font color of cell labels to black
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
# margins =c(12,9),     # widens margins around plot
col=my_palette,       # use on color palette defined earlier
#breaks=col_breaks,    # enable color transition at specified limits
dendrogram="row",     # only draw a row dendrogram
Colv="NA")            # turn off column clustering
dev.off()               # close the PNG device
#########################################################################################################
# read in csv file
pareto <- read.csv("pareto_fill..csv", header=T)
# assign row names
rownames(pareto) <- pareto[,1]
# make small heatmap
heatmap(t(as.matrix(pareto[300:372, 3:20])),
col=rainbow(100), na.rm=TRUE, scale="row", Rowv=NULL, Colv=NA, font.axis=200)
# make full heat map
heatmap(t(as.matrix(pareto[,3:ncol(pareto)])),
col=rainbow(100), na.rm=T, scale="row", RowV=NULL, Colv=NA, main="Normalised and pareto scaled")
library(gplots)
library(RColorBrewer)
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
col_breaks = c(seq(-1,0,length=100),  # for red
seq(0,0.8,length=100),              # for yellow
seq(0.8,1,length=100))              # for green
png("../heatmaps_in_r.png",    # create PNG for the heat map
width = 5*300,        # 5 x 300 pixels
height = 5*300,
res = 300,            # 300 pixels per inch
pointsize = 8)        # smaller font size
pareto <- read.csv("pareto_scale.csv", header=T)
rownames(pareto) <- pareto[,1]
pareto2 <- t(as.matrix(pareto[,2:ncol(pareto)]))
heatmap.2(pareto2,
#cellnote = pareto2,  # same data set for cell labels
main = "Pareto scaled and signal normalised", # heat map title
# notecol="none",      # change font color of cell labels to black
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
# margins =c(12,9),     # widens margins around plot
col=my_palette,       # use on color palette defined earlier
#breaks=col_breaks,    # enable color transition at specified limits
dendrogram="row",     # only draw a row dendrogram
Colv="NA")            # turn off column clustering
dev.off()               # close the PNG device
#########################################################################################################
# read in csv file
pareto <- read.csv("pareto_scale.csv", header=T)
# assign row names
rownames(pareto) <- pareto[,1]
# make small heatmap
heatmap(t(as.matrix(pareto[300:372, 3:20])),
col=rainbow(100), na.rm=TRUE, scale="row", Rowv=NULL, Colv=NA, font.axis=200)
# make full heat map
heatmap(t(as.matrix(pareto[,3:ncol(pareto)])),
col=rainbow(100), na.rm=T, scale="row", RowV=NULL, Colv=NA, main="Normalised and pareto scaled")
library(gplots)
library(RColorBrewer)
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
col_breaks = c(seq(-1,0,length=100),  # for red
seq(0,0.8,length=100),              # for yellow
seq(0.8,1,length=100))              # for green
png("../heatmaps_in_r.png",    # create PNG for the heat map
width = 5*300,        # 5 x 300 pixels
height = 5*300,
res = 300,            # 300 pixels per inch
pointsize = 8)        # smaller font size
pareto <- read.csv("pareto_scale.csv", header=T)
rownames(pareto) <- pareto[,1]
pareto2 <- t(as.matrix(pareto[,2:ncol(pareto)]))
heatmap.2(pareto2,
#cellnote = pareto2,  # same data set for cell labels
main = "Pareto scaled and signal normalised", # heat map title
# notecol="none",      # change font color of cell labels to black
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
# margins =c(12,9),     # widens margins around plot
col=my_palette,       # use on color palette defined earlier
#breaks=col_breaks,    # enable color transition at specified limits
dendrogram="row",     # only draw a row dendrogram
Colv="NA")            # turn off column clustering
dev.off()               # close the PNG device
library(gplots)
library(RColorBrewer)
my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
col_breaks = c(seq(-1,0,length=100),  # for red
seq(0,0.8,length=100),              # for yellow
seq(0.8,1,length=100))              # for green
png("../heatmaps_in_r.png",    # create PNG for the heat map
width = 5*300,        # 5 x 300 pixels
height = 5*300,
res = 300,            # 300 pixels per inch
pointsize = 8)        # smaller font size
pareto <- read.csv("pareto_scale.csv", header=T)
getwd()
list()
files()
ls()
dir()
pareto <- read.csv("pareto_scale.csv.csv", header=T)
rownames(pareto) <- pareto[,1]
pareto2 <- t(as.matrix(pareto[,2:ncol(pareto)]))
heatmap.2(pareto2,
#cellnote = pareto2,  # same data set for cell labels
main = "Pareto scaled and signal normalised", # heat map title
# notecol="none",      # change font color of cell labels to black
density.info="none",  # turns off density plot inside color legend
trace="none",         # turns off trace lines inside the heat map
# margins =c(12,9),     # widens margins around plot
col=my_palette,       # use on color palette defined earlier
#breaks=col_breaks,    # enable color transition at specified limits
dendrogram="row",     # only draw a row dendrogram
Colv="NA")            # turn off column clustering
dev.off()               # close the PNG device
pareto <- read.csv("pareto_scale.csv.csv", header=T)
# assign row names
rownames(pareto) <- pareto[,1]
# make small heatmap
heatmap(t(as.matrix(pareto[300:372, 3:20])),
col=rainbow(100), na.rm=TRUE, scale="row", Rowv=NULL, Colv=NA, font.axis=200)
# make full heat map
heatmap(t(as.matrix(pareto[,3:ncol(pareto)])),
col=rainbow(100), na.rm=T, scale="row", RowV=NULL, Colv=NA, main="Normalised and pareto scaled")
pareto <- read.csv("pareto_scale.csv.csv", header=T)
# assign row names
rownames(pareto) <- pareto[,1]
# make small heatmap
heatmap(t(as.matrix(pareto[300:372, 3:20])),
col=rainbow(100), na.rm=TRUE, scale="row", Rowv=NULL, Colv=NA, font.axis=200)
heatmap(t(as.matrix(pareto[300:372, 3:20])),
col=rainbow(100),  scale="row", Rowv=NULL, Colv=NA, font.axis=200)
heatmap(t(as.matrix(pareto[, 3:20])),
col=rainbow(100), na.rm=TRUE, scale="row", Rowv=NULL, Colv=NA, font.axis=200)
library("imageScope", lib.loc="~/R/win-library/3.1")
## WRITTEN BY NICK BOND, LPS. MARCH 2013
## directories ##
home_dir <- "C:/Users/hallz/Desktop/imageScope/"
lib_dir <- paste(home_dir,"libraries",sep="") # library files
spectra_dir <-  paste(home_dir,"Michele/pos/BB6",sep="") # spectra files
#output_dir <- "C:/Users/hallz/Desktop/imageScope/output" # output dir
##library variables
setwd(lib_dir)
## read in library files
read <- read.csv('lib_FA.csv', sep=",", header=T);lookup_FA <- read[,2:4]; row.names(lookup_FA) <- read[,1]
read <- read.csv('lib_class.csv', sep=",", header=T);lookup_lipid_class <- read[,2:3]; row.names(lookup_lipid_class) <- read[,1]
read <- read.csv('lib_element.csv', sep=",", header=T);lookup_element <- read[,2:3]; row.names(lookup_element) <- read[,1]
read <- read.csv('lib_modification.csv', sep=",", header=T);lookup_mod <- read[,2:ncol(read)]; row.names(lookup_mod ) <- read[,1]
FA_expt <-list('10','12','14','15','16','16.1','17','17.1','18','18.1','18.2','18.3','20.3','20.4','20.5','21','22','22.5','22.6','23','24.1')
#select class to be included in library
sel.class<- c( ## for pos
T, #TG
T, #DG
T, #PC
F, #PA
T, #PE
T, #PS
F, #PG
F, #PI
F, #PIP
F, #PIP2
F, #PIP3
T, #LysoPC
T, #DG-H20
T, #CE
F, #FFA
T, #SM
T  #Cer
)
imzMLparse<-  paste(home_dir,"imzMLConverter/imzMLConverter.jar",sep="") # spectra files
setwd(spectra_dir)
files <- list.files(, recursive = TRUE, full.names = TRUE,pattern = ".imzML")
setwd(spectra_dir)
.jinit()
.jaddClassPath(path=imzMLparse)
imzML <- J("imzMLConverter.ImzMLHandler")$parseimzML(paste(getwd(),substr(files,2,100),sep=''))
x.cood <- J(imzML, 'getWidth')
y.cood <- J(imzML, 'getHeight')
###################################### simple parameters #########################################
process=T
pca=T
slice=F
sel.class
fixed = F
fixed_FA
lookup_lipid_class
lookup_FA
lookup_element
files
thres.int = 500000
thres.low = 200
thres.high = 1100
spectra_dir
imzMLparse="C:/Users/hallz/Desktop/imageScope/imzMLConverter/imzMLConverter.jar"
bin.ppm = 12
percentage.deiso = 3
steps = seq(0, 1, 0.05)
thres.filter = 11
ppm = 3
no_isotopes = 2
prop.1 = 0.9
prop.2 = 0.5
search.mod = T
mod = c(NL = T, label = F, oxidised = T, desat = T)
lookup_mod
adducts = c(H = T, NH4 = F, Na = T, K = T, dH = F, Cl = F, OAc = F)
ppm.annotate = 15
image.ann=image.ann
norm.type = "TIC"
standards = NULL
scale.type = "cs"
transform = F
row = 50
scale = 100
x.cood = x.cood
y.cood = y.cood
nlevels = 50
name = ""
subname = ""
res.spatial = 50
rem.outliers = "only"
summary = T
title = T
PCnum = 5
percent = 5
offset=4
paretoScale<-function(imagedata.in, scale.type="pareto", transform=F, offset=4){
matr <-as.matrix(imagedata.in[,(offset+1):ncol(imagedata.in)])
matr[matr == 0] <- NA # replace zeros for NA so they are ommited from center and scaling
if(scale.type =="pareto"){
matr <-t(scale(t(matr), center = FALSE, scale=apply(t(matr),2,function(x) sqrt(sd(x,na.rm=TRUE))))) #pareto scale only for slicing=T
}
# replace NA with value (in this case 0)
matr[which(is.na(matr))]=0;
image.pareto <- cbind(imagedata.in[,1:offset], matr)
return(image.pareto)
}
dbase <-makelibrary(sel.class, fixed, fixed_FA, lookup_lipid_class,lookup_FA, lookup_element)
print(paste("library containing", ncol(dbase),"entries was made",sep=" "))
setwd(spectra_dir)
extracted<-mzextractor(files, spectra_dir, imzMLparse,thres.int, thres.low, thres.high)
peaks <- peakpicker.bin(extracted, bin.ppm) #pick peaks
temp.image <-  subset.image(extracted, peaks, percentage.deiso,thres.int, thres.low, thres.high, files, spectra_dir,imzMLparse)
temp.image.filtered <- filter(imagedata.in=temp.image, steps, thres.filter, offset = 1)
deisotoped<-deisotope(ppm, no_isotopes, prop.1, prop.2, peaks=list("",temp.image.filtered[,1]), image.sub=temp.image.filtered, search.mod, mod, lookup_mod)
annotated<-annotate(deisotoped, adducts,ppm.annotate, dbase)
final.image<-contructImage(extracted, deisotoped, peaks, imzMLparse, spectra_dir, thres.int, thres.low, thres.high, files)
ids<-cbind(deisotoped[[2]][,1],annotated,deisotoped[[2]][,3:4])
image.ann <- cbind(ids, final.image[,2:ncol(final.image)]) # create annotated image
getwd()
setwd(spectra_dir)
